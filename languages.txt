package SismageIO;

import javafx.geometry.Point3D;

public class UtilsMDToTVD {

    public static Point3D[] computeMinCurvature_XY_TVDSS_from_CurvMDDipAz(double wellHeadX, double wellHeadY, double wellHeadElevation, double[] CurvMD, double[] CurvDip, double[] CurvAzim) {
        // This method computes the XYZ points using the minimum curvature Bourgoyne algorithm.
        // It takes wellHeadX, wellHeadY, wellHeadElevation as starting points and vectors CurvMD, CurvDip, CurvAzim.
        // It returns an array of Point3D objects representing the computed points.
        // It iterates over the vectors to calculate XYZ coordinates based on the provided algorithm.
        // The computed points are stored in the Point3D array and returned at the end.
    }

    public static Point3D computeMinCurvature_XYZ_atMD(double wellHeadX, double wellHeadY, double wellHeadElevation, double[] CurvMD, double[] CurvDip, double[] CurvAzim, double MDMarker) {
        // This method computes the specific XYZ point for a given MD along the trajectory using a precise minimum curvature algorithm.
        // It calls computeMinCurvature_XY_TVDSS_from_CurvMDDipAz to get all the trajectory points.
        // Then, it calculates the indices before and after the MDMarker in the trajectory.
        // It calculates XYZ coordinates based on certain formulas and returns a Point3D object.
    }

    public static double[] computeTVDFromMD(double[] md, double[] dx, double[] dy) {
        // This method computes TVD (True Vertical Depth) from MD (Measured Depth) using a given set of vectors.
        // It calculates TVD values based on provided MD, dx, and dy vectors using mathematical formulas.
        // The resulting TVD values are stored in the res array and returned.
    }

    public static double computeTVD_from_MDDXDY_atMD(double[] mD, double[] dX, double[] dY, double MDMarker) throws Exception {
        // This method computes TVDRT (True Vertical Depth referenced to a reference datum) from MD, dX, and dY at a specific MD marker.
        // It first computes the TVD values using computeTVDFromMD method.
        // Then, it interpolates TVDRT based on the provided MD marker using a simple interpolation formula.
        // If the MD marker is out of the trajectory range, it throws an exception.
    }
}


In summary, this Java class UtilsMDToTVD contains several methods for converting and computing various depth-related measurements used in the oil and gas industry, particularly in well drilling operations. The methods involve mathematical calculations to determine the XYZ coordinates and TVD values based on provided inputs such as MD, dip, azimuth, etc. These calculations help in converting measurements from one depth reference to another and in estimating vertical depths along a well trajectory.

The class is designed to facilitate these conversions and calculations, making it easier for software applications in the industry to perform necessary depth-related computations. It provides a set of utility methods that can be used in a larger software system for analyzing and visualizing well data.




import static org.junit.Assert.*;
import javafx.geometry.Point3D;
import org.junit.Test;

public class UtilsMDToTVDTest {

    @Test
    public void testComputeMinCurvature_XY_TVDSS_from_CurvMDDipAz() {
        double wellHeadX = 100.0;
        double wellHeadY = 200.0;
        double wellHeadElevation = 0.0;

        double[] CurvMD = { 0.0, 100.0, 200.0, 300.0 };
        double[] CurvDip = { 0.0, 10.0, 20.0, 30.0 };
        double[] CurvAzim = { 0.0, 45.0, 90.0, 135.0 };

        Point3D[] result = UtilsMDToTVD.computeMinCurvature_XY_TVDSS_from_CurvMDDipAz(wellHeadX, wellHeadY, wellHeadElevation, CurvMD, CurvDip, CurvAzim);

        assertNotNull(result);
        assertEquals(4, result.length);

        // Add more assertions based on your expectations for the computed XYZ points.
    }

    @Test
    public void testComputeMinCurvature_XYZ_atMD() {
        double wellHeadX = 100.0;
        double wellHeadY = 200.0;
        double wellHeadElevation = 0.0;

        double[] CurvMD = { 0.0, 100.0, 200.0, 300.0 };
        double[] CurvDip = { 0.0, 10.0, 20.0, 30.0 };
        double[] CurvAzim = { 0.0, 45.0, 90.0, 135.0 };

        double MDMarker = 150.0;

        Point3D result = UtilsMDToTVD.computeMinCurvature_XYZ_atMD(wellHeadX, wellHeadY, wellHeadElevation, CurvMD, CurvDip, CurvAzim, MDMarker);

        assertNotNull(result);

        // Add assertions based on your expectations for the computed XYZ point.
    }

    @Test
    public void testComputeTVDFromMD() {
        double[] md = { 0.0, 100.0, 200.0, 300.0 };
        double[] dx = { 0.0, 10.0, 20.0, 30.0 };
        double[] dy = { 0.0, 5.0, 10.0, 15.0 };

        double[] result = UtilsMDToTVD.computeTVDFromMD(md, dx, dy);

        assertNotNull(result);
        assertEquals(4, result.length);

        // Add more assertions based on your expectations for the computed TVD values.
    }

    @Test
    public void testComputeTVD_from_MDDXDY_atMD() throws Exception {
        double[] md = { 0.0, 100.0, 200.0, 300.0 };
        double[] dx = { 0.0, 10.0, 20.0, 30.0 };
        double[] dy = { 0.0, 5.0, 10.0, 15.0 };

        double MDMarker = 150.0;

        double result = UtilsMDToTVD.computeTVD_from_MDDXDY_atMD(md, dx, dy, MDMarker);

        // Add assertions based on your expectations for the computed TVDRT value.
    }
}




/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package SismageIO;

import javafx.geometry.Point3D;



/**
 *
 * @author j0015562
 */
public class UtilsMDToTVD {
     /**
     * compute the points in XYZ from values in MD,Dip,Azimuth applying Min curvature Bourgoyne algo.
     * @param wellHeadX
     * @param wellHeadY
     * @param wellHeadElevation: positive if above sea surface.
     * @param CurvMD: MD vector
     * @param CurvDip: Dip vector
     * @param CurvAzim: Azim vector
     * @return 
     */
    
    public static Point3D[] computeMinCurvature_XY_TVDSS_from_CurvMDDipAz(double wellHeadX,double wellHeadY,double wellHeadElevation,double[] CurvMD, double[] CurvDip, double[] CurvAzim) {

    Point3D[] Pout = new Point3D[CurvMD.length];
    double i2, i1, a2, a1, DL, DLdeg;
    double Xout, Yout, Zout;
    double pi = Math.PI;

    //initial z is defined at elevation position with a negative sign.
    //because output is TVDSS
    Pout[0] = new Point3D(wellHeadX,wellHeadY,-wellHeadElevation);
    
    
    

    for (int k = 1; k < CurvMD.length; k++) {

      i2 = CurvDip[k] * pi / 180;
      i1 = CurvDip[k - 1] * pi / 180;

      a2 = CurvAzim[k] * pi / 180;
      a1 = CurvAzim[k - 1] * pi / 180;

      //Compute DogLeg
      DL = Math.acos(Math.cos(i2 - i1) - (Math.sin(i2) * Math.sin(i1) * (1 - Math.cos(a2 - a1))));
      DLdeg = DL * 180.0 / pi;
      //compute Ratio Factor
      double RF;
      if (DL > 0.0001) RF = (360.0 / DLdeg / pi) * Math.tan(DL / 2);
      else RF = 1;

      //Compute next point coordinates that respects the criteria= Update trajectory in X,Y,Z !!!

      Zout = Pout[k - 1].getZ() + (CurvMD[k] - CurvMD[k - 1]) / 2 * (Math.cos(i1) + Math.cos(i2)) * RF;
      Yout = Pout[k - 1].getY() + (CurvMD[k] - CurvMD[k - 1]) / 2 * (Math.sin(i1) * Math.cos(a1) + Math.sin(i2) * Math.cos(a2)) * RF;
      Xout = Pout[k - 1].getX() + (CurvMD[k] - CurvMD[k - 1]) / 2 * (Math.sin(i1) * Math.sin(a1) + Math.sin(i2) * Math.sin(a2)) * RF;

      Pout[k] = new Point3D(Xout, Yout, Zout);

    }

    return Pout;

  }

    
/**
 * compute the specific Point XYZ for a specific MD along trajectory, applying precise min cuvature algo.
     * @param wellHeadX
 * @param CurvMD: vector of MD values
     * @param wellHeadElevation
     * @param wellHeadY
 * @param CurvDip: vector of dip values
 * @param CurvAzim: vector of azimuth
 * @param MDMarker: MD value we want to convert as a point.
 * @return 
 */
    public static Point3D computeMinCurvature_XYZ_atMD(double wellHeadX,double wellHeadY,double wellHeadElevation,double[] CurvMD, double[] CurvDip, double[] CurvAzim, double MDMarker)  {

    Point3D[] allpoints=computeMinCurvature_XY_TVDSS_from_CurvMDDipAz(wellHeadX,wellHeadY,wellHeadElevation,CurvMD, CurvDip, CurvAzim);
    //Find the points of the trajectory that are before and after.
    int indexAfter=0;
    for(int k=0;k<CurvMD.length;k++){
        if(CurvMD[k]>=MDMarker){
            indexAfter=k;
            break;
        }
    }
      
    //Point3D pMarker = new Point3D();
    double i2, i1, a2, a1, DL, DLdeg;
    double Xout, Yout, Zout;
    double pi = Math.PI;

      i2 = CurvDip[indexAfter] * pi / 180;
      i1 = CurvDip[indexAfter - 1] * pi / 180;

      a2 = CurvAzim[indexAfter] * pi / 180;
      a1 = CurvAzim[indexAfter - 1] * pi / 180;

      //Compute DogLeg
      DL = Math.acos(Math.cos(i2 - i1) - (Math.sin(i2) * Math.sin(i1) * (1 - Math.cos(a2 - a1))));
      DLdeg = DL * 180.0 / pi;
      
      double xxout=0;
      double yyout=0;
      double zzout=0;
      
      double dmd=CurvMD[indexAfter] - CurvMD[indexAfter - 1];
      double ratio=(MDMarker-CurvMD[indexAfter - 1])/(CurvMD[indexAfter] - CurvMD[indexAfter - 1]);
      
        //% Calculation of coordinates in y direction based on minimum
        double ay=(Math.sin(i2)*Math.cos(a2)-Math.sin(i1)*Math.cos(a1)*Math.cos(DL))/Math.sin(DL);
        yyout=allpoints[indexAfter-1].getY()+dmd/DL*(-ay*Math.cos(ratio*DL)+Math.sin(i1)*Math.cos(a1)*Math.sin(ratio*DL)+ay);
        
        //% Calculation of coordinates in x direction based on minimum
        //% curvature
        double ax=(Math.sin(i2)*Math.sin(a2)-Math.sin(i1)*Math.sin(a1)*Math.cos(DL))/Math.sin(DL);
        xxout=allpoints[indexAfter-1].getX()+dmd/DL*(-ax*Math.cos(ratio*DL)+Math.sin(i1)*Math.sin(a1)*Math.sin(ratio*DL)+ax);
       
        //% Calculation of coordinates in z direction based on minimum
        //% curvature
        double az=(Math.cos(i2)-Math.cos(i1)*Math.cos(DL))/Math.sin(DL);
        zzout=allpoints[indexAfter-1].getZ()+dmd/DL*(-az*Math.cos(ratio*DL)+Math.cos(i2)*Math.sin(ratio*DL)+az);
        
        
    

    return new Point3D(xxout,yyout,zzout);

  }
  /**
   * tvd from md with some robust behaviour in case of wrong inputs.
   * @param md
   * @param dx
   * @param dy
   * @return 
   */  
  public static double[] computeTVDFromMD(double[] md, double[] dx, double[] dy) {
    
    double[] res = new double[md.length];

    if (res.length <= 0) return res;

    res[0] = Math.sqrt((md[0] * md[0]) - (dx[0] * dx[0]) - (dy[0] * dy[0]));

    // si donnees incoherentes.....
    if (Double.isNaN(res[0])) res[0] = md[0];

    for (int i = 1; i < md.length; i++) {
      double vdx = dx[i] - dx[i - 1];
      double vdy = dy[i] - dy[i - 1];
      double currentMd = md[i] - md[i - 1];
      // The sign of Delta_md is always positive but the sign
      // of Delta_tvd can be positive or negative...
      double sign = currentMd < 0 ? -1 : 1;

      // Here we have to check that it is possible to apply pythagore.
      // sometimes we can encounter files for which md*md-dx*dx-dy*dy <0 !!
      // => Math.sqrt(md*md-dx*dx-dy*dy)=NaN !!
      // if it is the case, the error is propagated through the next point
      // unit the end of the file.
      if (((currentMd * currentMd) - (vdx * vdx) - (vdy * vdy)) >= 0.0) {
        res[i] = (sign * Math.sqrt((currentMd * currentMd) - (vdx * vdx) - (vdy * vdy))) + res[i - 1];
      }
      else {
        res[i] = res[i - 1];
      }
    }

    return res;
  }
  /**
   * simple way to compute TVDRT from MD. Warning: Approximation of the trajectory as a set of segments. Valid for almost vertical wells.
   * @param mD
   * @param dX
   * @param dY
   * @param MDMarker
   * @return
   * @throws Exception 
   */  
  public static double computeTVD_from_MDDXDY_atMD(double[] mD, double[] dX, double[] dY, double MDMarker) throws Exception  {
    
    //Find the points of the trajectory that are before and after.
    int indexAfter=0;
    
    double[] tvdRTVector=computeTVDFromMD(mD, dX, dY) ;
    boolean mdExist=false;
    
    for(int k=1;k<mD.length;k++){
        
        if(mD[k]>=MDMarker){
            indexAfter=k;
            mdExist=true;
            break;
        }
    }
    if(!mdExist){
        //md is out of the range of the trajectory
        throw new Exception("md is out of the range of the trajectory");
    }
    //interpolate TVD from segment
    double ratio=(MDMarker-mD[indexAfter-1])/(mD[indexAfter]-mD[indexAfter-1]);
    //Thales
    double tvdRT=tvdRTVector[indexAfter-1]+ratio*(tvdRTVector[indexAfter]-tvdRTVector[indexAfter-1]);
    return tvdRT;
   
  }  
}
